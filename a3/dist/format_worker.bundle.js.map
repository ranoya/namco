{"version":3,"file":"format_worker.bundle.js","mappings":"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","sources":["webpack://apple2js/./js/util.ts","webpack://apple2js/./js/base64.ts","webpack://apple2js/./js/formats/types.ts","webpack://apple2js/./js/formats/format_utils.ts","webpack://apple2js/./js/formats/do.ts","webpack://apple2js/./js/formats/nib.ts","webpack://apple2js/./js/formats/prodos/constants.ts","webpack://apple2js/./js/formats/po.ts","webpack://apple2js/./js/formats/2mg.ts","webpack://apple2js/./js/formats/woz.ts","webpack://apple2js/./js/formats/create_disk.ts","webpack://apple2js/./js/formats/d13.ts","webpack://apple2js/./workers/format.worker.ts","webpack://apple2js/./js/types.ts"],"sourcesContent":["import { byte, memory } from './types';\n\n/*eslint no-console: 0*/\n\nconst hex_digits = '0123456789ABCDEF';\nconst bin_digits = '01';\n\n/** Returns a random byte. */\nexport function garbage(): byte {\n    return (Math.random() * 0x100) & 0xff;\n}\n\nexport const testables = {\n    garbage,\n};\n\n/**\n * Returns an array or Uint8Array of `size` bytes filled as if the computer\n * was just powered on.\n */\nexport function allocMem(size: number) {\n    const result = new Uint8Array(size);\n\n    for (let idx = 0; idx < size; idx++) {\n        result[idx] = idx & 0x02 ? 0x00 : 0xff;\n    }\n    // Borrowed from AppleWin (https://github.com/AppleWin/AppleWin)\n    for (let idx = 0; idx < size; idx += 0x200) {\n        result[idx + 0x28] = garbage();\n        result[idx + 0x29] = garbage();\n        result[idx + 0x68] = garbage();\n        result[idx + 0x69] = garbage();\n    }\n    return result;\n}\n\n/** Returns an array or Uint8Array of 256 * `pages` bytes. */\nexport function allocMemPages(pages: number): memory {\n    return allocMem(pages << 8);\n}\n\n/** Returns a new Uint8Array for the input array. */\nexport function bytify(ary: number[]): memory {\n    return new Uint8Array(ary);\n}\n\n/** Returns a new Uint8Array with the concatenated data from the inputs. */\nexport function concat(...arys: Array<byte[] | Uint8Array>) {\n    const result = new Uint8Array(arys.reduce((l, ary) => l + ary.length, 0));\n    let offset = 0;\n    for (let i = 0; i < arys.length; i++) {\n        result.set(arys[i], offset);\n        offset += arys[i].length;\n    }\n    return result;\n}\n\n/** Writes to the console. */\nexport function debug(...args: unknown[]): void {\n    console.log(...args);\n}\n\n/**\n * Returns a string of hex digits (all caps).\n * @param v the value to encode\n * @param n the number of nibbles. If `n` is missing, it is guessed from the value\n *     of `v`. If `v` < 256, it is assumed to be 2 nibbles, otherwise 4.\n */\nexport function toHex(v: number, n?: number) {\n    if (!n) {\n        n = v < 256 ? 2 : 4;\n    }\n    let result = '';\n    for (let idx = 0; idx < n; idx++) {\n        result = hex_digits[v & 0x0f] + result;\n        v >>= 4;\n    }\n    return result;\n}\n\n/**\n * Returns a string of 8 binary digits.\n * @param v the value to encode\n */\nexport function toBinary(v: byte) {\n    let result = '';\n    for (let idx = 0; idx < 8; idx++) {\n        result = bin_digits[v & 0x01] + result;\n        v >>= 1;\n    }\n    return result;\n}\n","import { memory } from './types';\n\nconst B64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\n/** Encode an array of bytes in base64. */\nexport function base64_encode(data: null | undefined): undefined;\nexport function base64_encode(data: memory): string;\nexport function base64_encode(\n    data: memory | null | undefined\n): string | undefined {\n    // Twacked by Will Scullin to handle arrays of 'bytes'\n\n    // http://kevin.vanzonneveld.net\n    // +   original by: Tyler Akins (http://rumkin.com)\n    // +   improved by: Bayron Guevara\n    // +   improved by: Thunder.m\n    // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n    // +   bugfixed by: Pellentesque Malesuada\n    // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n    // -    depends on: utf8_encode\n    // *     example 1: base64_encode('Kevin van Zonneveld');\n    // *     returns 1: 'S2V2aW4gdmFuIFpvbm5ldmVsZA=='\n\n    // mozilla has this native\n    // - but breaks in 2.0.0.12!\n    //if (typeof this.window['atob'] == 'function') {\n    //    return atob(data);\n    //}\n\n    let o1,\n        o2,\n        o3,\n        h1,\n        h2,\n        h3,\n        h4,\n        bits,\n        i = 0,\n        ac = 0,\n        enc = '';\n    const tmp_arr = [];\n\n    if (!data) {\n        return undefined;\n    }\n\n    do {\n        // pack three octets into four hexets\n        o1 = data[i++];\n        o2 = data[i++];\n        o3 = data[i++];\n\n        bits = (o1 << 16) | (o2 << 8) | o3;\n\n        h1 = (bits >> 18) & 0x3f;\n        h2 = (bits >> 12) & 0x3f;\n        h3 = (bits >> 6) & 0x3f;\n        h4 = bits & 0x3f;\n\n        // use hexets to index into b64, and append result to encoded string\n        tmp_arr[ac++] =\n            B64.charAt(h1) + B64.charAt(h2) + B64.charAt(h3) + B64.charAt(h4);\n    } while (i < data.length);\n\n    enc = tmp_arr.join('');\n\n    switch (data.length % 3) {\n        case 1:\n            enc = enc.slice(0, -2) + '==';\n            break;\n        case 2:\n            enc = enc.slice(0, -1) + '=';\n            break;\n    }\n\n    return enc;\n}\n\n/** Returns undefined if the input is null or undefined. */\nexport function base64_decode(data: null | undefined): undefined;\n/** Returns an array of bytes from the given base64-encoded string. */\nexport function base64_decode(data: string): memory;\n/** Returns an array of bytes from the given base64-encoded string. */\nexport function base64_decode(\n    data: string | null | undefined\n): memory | undefined {\n    // Twacked by Will Scullin to handle arrays of 'bytes'\n\n    // http://kevin.vanzonneveld.net\n    // +   original by: Tyler Akins (http://rumkin.com)\n    // +   improved by: Thunder.m\n    // +      input by: Aman Gupta\n    // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n    // +   bugfixed by: Onno Marsman\n    // +   bugfixed by: Pellentesque Malesuada\n    // +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n    // +      input by: Brett Zamir (http://brett-zamir.me)\n    // +   bugfixed by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n    // -    depends on: utf8_decode\n    // *     example 1: base64_decode('S2V2aW4gdmFuIFpvbm5ldmVsZA==');\n    // *     returns 1: 'Kevin van Zonneveld'\n\n    // mozilla has this native\n    // - but breaks in 2.0.0.12!\n    //if (typeof this.window['btoa'] == 'function') {\n    //    return btoa(data);\n    //}\n\n    let o1,\n        o2,\n        o3,\n        h1,\n        h2,\n        h3,\n        h4,\n        bits,\n        i = 0,\n        ac = 0;\n    const tmp_arr = [];\n\n    if (!data) {\n        return undefined;\n    }\n\n    do {\n        // unpack four hexets into three octets using index points in B64\n        h1 = B64.indexOf(data.charAt(i++));\n        h2 = B64.indexOf(data.charAt(i++));\n        h3 = B64.indexOf(data.charAt(i++));\n        h4 = B64.indexOf(data.charAt(i++));\n\n        bits = (h1 << 18) | (h2 << 12) | (h3 << 6) | h4;\n\n        o1 = (bits >> 16) & 0xff;\n        o2 = (bits >> 8) & 0xff;\n        o3 = bits & 0xff;\n\n        tmp_arr[ac++] = o1;\n        if (h3 !== 64) {\n            tmp_arr[ac++] = o2;\n        }\n        if (h4 !== 64) {\n            tmp_arr[ac++] = o3;\n        }\n    } while (i < data.length);\n\n    return new Uint8Array(tmp_arr);\n}\n\nconst DATA_URL_PREFIX = 'data:application/octet-stream;base64,';\n\nexport function base64_json_parse(json: string): unknown {\n    const reviver = (_key: string, value: unknown) => {\n        if (typeof value === 'string' && value.startsWith(DATA_URL_PREFIX)) {\n            return base64_decode(value.slice(DATA_URL_PREFIX.length));\n        }\n        return value;\n    };\n\n    return JSON.parse(json, reviver);\n}\n\nexport function base64_json_stringify(json: unknown) {\n    const replacer = (_key: string, value: unknown) => {\n        if (value instanceof Uint8Array) {\n            return DATA_URL_PREFIX + base64_encode(value);\n        }\n        return value;\n    };\n\n    return JSON.stringify(json, replacer);\n}\n","import type { byte, memory, MemberOf, word } from '../types';\nimport type { GamepadConfiguration } from '../ui/types';\nimport { InfoChunk } from './woz';\n\nexport const SUPPORTED_SECTORS = [13, 16] as const;\nexport type SupportedSectors = MemberOf<typeof SUPPORTED_SECTORS>;\n\nexport const DRIVE_NUMBERS = [1, 2] as const;\nexport type DriveNumber = MemberOf<typeof DRIVE_NUMBERS>;\n\n/**\n * Arguments for the disk format processors.\n */\nexport interface DiskOptions {\n    name: string;\n    side?: string | undefined;\n    volume: byte;\n    readOnly: boolean;\n    data?: memory[][];\n    rawData?: ArrayBuffer;\n    blockVolume?: boolean;\n}\n\n/**\n * JSON file entry format\n */\nexport interface DiskDescriptor {\n    name: string;\n    disk?: number;\n    filename: string;\n    e?: boolean;\n    category: string;\n}\n\n/**\n * JSON binary image (not used?)\n */\nexport interface JSONBinaryImage {\n    type: 'binary';\n    start: word;\n    length: word;\n    data: byte[];\n    gamepad?: GamepadConfiguration;\n}\n\n/**\n * Information about a disk image not directly related to the\n * disk contents. For example, the name or even a scan of the\n * disk label are \"metadata\", but the volume number is not.\n */\nexport interface DiskMetadata {\n    /** Displayed disk name */\n    name: string;\n    /** (Optional) Disk side (Front/Back, A/B) */\n    side?: string | undefined;\n}\n\n/**\n * Return value from disk format processors. Describes raw disk\n * data which the DiskII card can process.\n */\nexport interface Disk {\n    metadata: DiskMetadata;\n    readOnly: boolean;\n}\n\nexport const NO_DISK = 'empty';\nexport const ENCODING_NIBBLE = 'nibble';\nexport const ENCODING_BITSTREAM = 'bitstream';\nexport const ENCODING_BLOCK = 'block';\n\nexport interface FloppyDisk extends Disk {\n    encoding:\n        | typeof ENCODING_NIBBLE\n        | typeof ENCODING_BITSTREAM\n        | typeof NO_DISK;\n}\n\nexport interface NoFloppyDisk extends FloppyDisk {\n    encoding: typeof NO_DISK;\n}\n\nexport interface NibbleDisk extends FloppyDisk {\n    encoding: typeof ENCODING_NIBBLE;\n    format: Exclude<NibbleFormat, 'woz'>;\n    volume: byte;\n    tracks: memory[];\n}\n\nexport interface WozDisk extends FloppyDisk {\n    encoding: typeof ENCODING_BITSTREAM;\n    format: 'woz';\n    trackMap: number[];\n    rawTracks: Uint8Array[];\n    info: InfoChunk | undefined;\n}\n\nexport interface BlockDisk extends Disk {\n    encoding: typeof ENCODING_BLOCK;\n    format: BlockFormat;\n\n    blockCount(): Promise<number>;\n    read(block: number): Promise<Uint8Array>;\n    write(block: number, data: Uint8Array): Promise<void>;\n}\n\nexport class MemoryBlockDisk implements BlockDisk {\n    encoding: typeof ENCODING_BLOCK = ENCODING_BLOCK;\n\n    constructor(\n        readonly format: BlockFormat,\n        readonly metadata: DiskMetadata,\n        readonly readOnly = false,\n        private blocks: Uint8Array[]\n    ) {}\n\n    async blockCount(): Promise<number> {\n        return this.blocks.length;\n    }\n\n    async read(block: number): Promise<Uint8Array> {\n        return this.blocks[block];\n    }\n\n    async write(block: number, data: Uint8Array): Promise<void> {\n        this.blocks[block] = data;\n    }\n}\n\n/**\n * File types supported by floppy devices in nibble mode.\n */\nexport const NIBBLE_FORMATS = ['2mg', 'd13', 'do', 'dsk', 'po', 'nib'] as const;\n\n/**\n * File types supported by floppy devices in bitstream mode.\n */\nexport const BITSTREAM_FORMATS = ['woz'] as const;\n\n/**\n * All file types supported by floppy devices.\n */\nexport const FLOPPY_FORMATS = [\n    ...NIBBLE_FORMATS,\n    ...BITSTREAM_FORMATS,\n] as const;\n\n/**\n * File types supported by block devices.\n */\nexport const BLOCK_FORMATS = ['2mg', 'hdv', 'po'] as const;\n\n/**\n * All supported disk formats.\n */\nexport const DISK_FORMATS = [...FLOPPY_FORMATS, ...BLOCK_FORMATS] as const;\n\nexport type FloppyFormat = MemberOf<typeof FLOPPY_FORMATS>;\nexport type NibbleFormat = MemberOf<typeof NIBBLE_FORMATS>;\nexport type BitstreamFormat = 'woz';\nexport type BlockFormat = MemberOf<typeof BLOCK_FORMATS>;\nexport type DiskFormat = MemberOf<typeof DISK_FORMATS>;\n\n/** Type guard for nibble disk formats. */\nexport function isNibbleDiskFormat(f: DiskFormat): f is NibbleFormat {\n    return NIBBLE_FORMATS.includes(f as NibbleFormat);\n}\n\n/** Type guard for block disk formats. */\nexport function isBlockDiskFormat(f: DiskFormat): f is BlockFormat {\n    return BLOCK_FORMATS.includes(f as BlockFormat);\n}\n\nexport function isNoFloppyDisk(disk: Disk): disk is NoFloppyDisk {\n    return (disk as NoFloppyDisk)?.encoding === NO_DISK;\n}\n\n/** Type guard for NibbleDisks */\nexport function isNibbleDisk(disk: Disk): disk is NibbleDisk {\n    return (disk as NibbleDisk)?.encoding === ENCODING_NIBBLE;\n}\n\n/** Type guard for NibbleDisks */\nexport function isWozDisk(disk: Disk): disk is WozDisk {\n    return (disk as WozDisk)?.encoding === ENCODING_BITSTREAM;\n}\n\n/**\n * Base format for JSON defined disks\n */\n\nexport class JSONDiskBase {\n    type: DiskFormat;\n    name: string;\n    disk?: string;\n    category?: string;\n    volume?: byte;\n    readOnly?: boolean;\n    gamepad?: GamepadConfiguration;\n}\n\n/**\n * JSON Disk format with base64 encoded tracks with sectors\n */\n\nexport interface Base64JSONDisk extends JSONDiskBase {\n    type: Exclude<DiskFormat, 'nib'>;\n    encoding: 'base64';\n    data: string[][];\n}\n\n/**\n * JSON Disk format with base64 encoded nibblized tracks\n */\n\nexport interface Base64JSONNibbleDisk extends JSONDiskBase {\n    type: 'nib';\n    encoding: 'base64';\n    data: string[];\n}\n\n/**\n * JSON Disk format with byte array tracks\n */\n\nexport interface BinaryJSONDisk extends JSONDiskBase {\n    type: DiskFormat;\n    encoding: 'binary';\n    data: memory[][];\n}\n\n/**\n * General JSON Disk format\n */\n\nexport type JSONDisk = Base64JSONDisk | Base64JSONNibbleDisk | BinaryJSONDisk;\n\n/**\n * Process Disk message payloads for worker\n */\n\nexport const PROCESS_BINARY = 'PROCESS_BINARY';\nexport const PROCESS_JSON_DISK = 'PROCESS_JSON_DISK';\nexport const PROCESS_JSON = 'PROCESS_JSON';\n\n/** Binary disk file message */\nexport interface ProcessBinaryMessage {\n    type: typeof PROCESS_BINARY;\n    payload: {\n        driveNo: DriveNumber;\n        fmt: FloppyFormat;\n        options: DiskOptions;\n    };\n}\n\n/** Processed JSON file message (used for localStorage) */\nexport interface ProcessJsonDiskMessage {\n    type: typeof PROCESS_JSON_DISK;\n    payload: {\n        driveNo: DriveNumber;\n        jsonDisk: JSONDisk;\n    };\n}\n\n/** Raw JSON file message */\nexport interface ProcessJsonMessage {\n    type: typeof PROCESS_JSON;\n    payload: {\n        driveNo: DriveNumber;\n        json: string;\n    };\n}\n\nexport type FormatWorkerMessage =\n    | ProcessBinaryMessage\n    | ProcessJsonDiskMessage\n    | ProcessJsonMessage;\n\n/**\n * Format work result message type\n */\n\nexport const DISK_PROCESSED = 'DISK_PROCESSED';\n\nexport interface DiskProcessedResponse {\n    type: typeof DISK_PROCESSED;\n    payload: {\n        driveNo: DriveNumber;\n        disk: FloppyDisk | null;\n    };\n}\n\nexport type FormatWorkerResponse = DiskProcessedResponse;\n\nexport interface MassStorageData {\n    metadata: DiskMetadata;\n    ext: DiskFormat;\n    readOnly: boolean;\n    volume?: byte;\n    data: ArrayBuffer;\n}\n\n/**\n * Block device common interface\n */\nexport interface MassStorage<T> {\n    setBinary(\n        drive: number,\n        name: string,\n        ext: T,\n        data: ArrayBuffer\n    ): Promise<void>;\n    getBinary(drive: number, ext?: T): Promise<MassStorageData | null>;\n}\n\nexport interface BlockStorage extends MassStorage<BlockFormat> {\n    setBlockDisk(drive: number, blockDisk: BlockDisk): Promise<void>;\n    getBlockDisk(drive: number): Promise<BlockDisk | null>;\n}\n\nexport function isBlockStorage(\n    storage: MassStorage<unknown>\n): storage is BlockStorage {\n    return 'getBlockDisk' in storage;\n}\n","import { bit, byte, memory } from '../types';\nimport { base64_decode, base64_encode } from '../base64';\nimport { bytify, debug, toHex } from '../util';\nimport {\n    NibbleDisk,\n    ENCODING_NIBBLE,\n    JSONDisk,\n    isNibbleDiskFormat,\n    SupportedSectors,\n} from './types';\n\n/**\n * DOS 3.3 Physical sector order (index is physical sector, value is DOS sector).\n */\n// prettier-ignore\nexport const DO = [\n    0x0, 0x7, 0xe, 0x6, 0xd, 0x5, 0xc, 0x4,\n    0xb, 0x3, 0xa, 0x2, 0x9, 0x1, 0x8, 0xf,\n] as const;\n\n/**\n * DOS 3.3 Logical sector order (index is DOS sector, value is physical sector).\n */\n// prettier-ignore\nexport const _DO = [\n    0x0, 0xd, 0xb, 0x9, 0x7, 0x5, 0x3, 0x1,\n    0xe, 0xc, 0xa, 0x8, 0x6, 0x4, 0x2, 0xf,\n] as const;\n\n/**\n * ProDOS Physical sector order (index is physical sector, value is ProDOS sector).\n */\n// prettier-ignore\nexport const PO = [\n    0x0, 0x8, 0x1, 0x9, 0x2, 0xa, 0x3, 0xb,\n    0x4, 0xc, 0x5, 0xd, 0x6, 0xe, 0x7, 0xf,\n] as const;\n\n/**\n * ProDOS Logical sector order (index is ProDOS sector, value is physical sector).\n */\n// prettier-ignore\nexport const _PO = [\n    0x0, 0x2, 0x4, 0x6, 0x8, 0xa, 0xc, 0xe,\n    0x1, 0x3, 0x5, 0x7, 0x9, 0xb, 0xd, 0xf,\n] as const;\n\n/**\n * DOS 13-sector disk physical sector order (index is disk sector, value is\n * physical sector).\n */\nexport const D13O = [\n    0x0, 0xa, 0x7, 0x4, 0x1, 0xb, 0x8, 0x5, 0x2, 0xc, 0x9, 0x6, 0x3,\n] as const;\n\nexport const _D13O = [\n    0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xa, 0xb, 0xc,\n] as const;\n\n// prettier-ignore\nconst TRANS53 = [\n    0xab, 0xad, 0xae, 0xaf, 0xb5, 0xb6, 0xb7, 0xba,\n    0xbb, 0xbd, 0xbe, 0xbf, 0xd6, 0xd7, 0xda, 0xdb,\n    0xdd, 0xde, 0xdf, 0xea, 0xeb, 0xed, 0xee, 0xef,\n    0xf5, 0xf6, 0xf7, 0xfa, 0xfb, 0xfd, 0xfe, 0xff\n] as const;\n\n// prettier-ignore\nexport const DETRANS53 = [\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // A0\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03, // A8\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x05, 0x06, // B0\n    0x00, 0x00, 0x07, 0x08, 0x00, 0x09, 0x0A, 0x0B, // B8\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // C0\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // C8\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0D, // D0\n    0x00, 0x00, 0x0E, 0x0F, 0x00, 0x10, 0x11, 0x12, // D8\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // E0\n    0x00, 0x00, 0x13, 0x14, 0x00, 0x15, 0x16, 0x17, // E8\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x19, 0x1A, // F0\n    0x00, 0x00, 0x1B, 0x1C, 0x00, 0x1D, 0x1E, 0x1F, // F8\n] as const;\n\n// prettier-ignore\nconst TRANS62 = [\n    0x96, 0x97, 0x9a, 0x9b, 0x9d, 0x9e, 0x9f, 0xa6,\n    0xa7, 0xab, 0xac, 0xad, 0xae, 0xaf, 0xb2, 0xb3,\n    0xb4, 0xb5, 0xb6, 0xb7, 0xb9, 0xba, 0xbb, 0xbc,\n    0xbd, 0xbe, 0xbf, 0xcb, 0xcd, 0xce, 0xcf, 0xd3,\n    0xd6, 0xd7, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde,\n    0xdf, 0xe5, 0xe6, 0xe7, 0xe9, 0xea, 0xeb, 0xec,\n    0xed, 0xee, 0xef, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6,\n    0xf7, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff\n] as const;\n\n// prettier-ignore\nexport const DETRANS62 = [\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,\n    0x00, 0x00, 0x02, 0x03, 0x00, 0x04, 0x05, 0x06,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x08,\n    0x00, 0x00, 0x00, 0x09, 0x0A, 0x0B, 0x0C, 0x0D,\n    0x00, 0x00, 0x0E, 0x0F, 0x10, 0x11, 0x12, 0x13,\n    0x00, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x1B, 0x00, 0x1C, 0x1D, 0x1E,\n    0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x20, 0x21,\n    0x00, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x29, 0x2A, 0x2B,\n    0x00, 0x2C, 0x2D, 0x2E, 0x2F, 0x30, 0x31, 0x32,\n    0x00, 0x00, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38,\n    0x00, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F\n] as const;\n\n/**\n * Converts a byte into its 4x4 encoded representation\n *\n * @param val byte to encode.\n * @returns A two byte array of representing the 4x4 encoding.\n */\nexport function fourXfour(val: byte): [xx: byte, yy: byte] {\n    let xx = val & 0xaa;\n    let yy = val & 0x55;\n\n    xx >>= 1;\n    xx |= 0xaa;\n    yy |= 0xaa;\n\n    return [xx, yy];\n}\n\n/**\n * Converts 2 4x4 encoded bytes into a byte value\n *\n * @param xx First encoded byte.\n * @param yy Second encoded byte.\n * @returns The decoded value.\n */\nexport function defourXfour(xx: byte, yy: byte): byte {\n    return ((xx << 1) | 0x01) & yy;\n}\n\n/**\n * Converts a raw sector into a nibblized representation to be combined into a\n * nibblized 16 sector track.\n *\n * @param volume volume number\n * @param track track number\n * @param sector sector number\n * @param data sector data\n * @returns a nibblized representation of the sector data\n */\nexport function explodeSector16(\n    volume: byte,\n    track: byte,\n    sector: byte,\n    data: memory\n): byte[] {\n    let buf = [];\n    let gap;\n\n    /*\n     * Gap 1/3 (40/0x28 bytes)\n     */\n\n    if (sector === 0)\n        // Gap 1\n        gap = 0x80;\n    else {\n        // Gap 3\n        gap = track === 0 ? 0x28 : 0x26;\n    }\n\n    for (let idx = 0; idx < gap; idx++) {\n        buf.push(0xff);\n    }\n\n    /*\n     * Address Field\n     */\n\n    const checksum = volume ^ track ^ sector;\n    buf = buf.concat([0xd5, 0xaa, 0x96]); // Address Prolog D5 AA 96\n    buf = buf.concat(fourXfour(volume));\n    buf = buf.concat(fourXfour(track));\n    buf = buf.concat(fourXfour(sector));\n    buf = buf.concat(fourXfour(checksum));\n    buf = buf.concat([0xde, 0xaa, 0xeb]); // Epilog DE AA EB\n\n    /*\n     * Gap 2 (5 bytes)\n     */\n\n    for (let idx = 0; idx < 0x05; idx++) {\n        buf.push(0xff);\n    }\n\n    /*\n     * Data Field\n     */\n\n    buf = buf.concat([0xd5, 0xaa, 0xad]); // Data Prolog D5 AA AD\n\n    const nibbles: byte[] = [];\n    const ptr2 = 0;\n    const ptr6 = 0x56;\n\n    for (let idx = 0; idx < 0x156; idx++) {\n        nibbles[idx] = 0;\n    }\n\n    let idx2 = 0x55;\n    for (let idx6 = 0x101; idx6 >= 0; idx6--) {\n        let val6 = data[idx6 % 0x100];\n        let val2: byte = nibbles[ptr2 + idx2];\n\n        val2 = (val2 << 1) | (val6 & 1);\n        val6 >>= 1;\n        val2 = (val2 << 1) | (val6 & 1);\n        val6 >>= 1;\n\n        nibbles[ptr6 + idx6] = val6;\n        nibbles[ptr2 + idx2] = val2;\n\n        if (--idx2 < 0) idx2 = 0x55;\n    }\n\n    let last = 0;\n    for (let idx = 0; idx < 0x156; idx++) {\n        const val = nibbles[idx];\n        buf.push(TRANS62[last ^ val]);\n        last = val;\n    }\n    buf.push(TRANS62[last]);\n\n    buf = buf.concat([0xde, 0xaa, 0xeb]); // Epilog DE AA EB\n\n    /*\n     * Gap 3\n     */\n\n    buf.push(0xff);\n\n    return buf;\n}\n\n/**\n * Converts a raw sector into a nibblized representation to be combined into\n * a nibblized 13 sector track.\n *\n * @param volume volume number\n * @param track track number\n * @param sector sector number\n * @param data sector data\n * @returns a nibblized representation of the sector data\n */\nexport function explodeSector13(\n    volume: byte,\n    track: byte,\n    sector: byte,\n    data: memory\n): byte[] {\n    let buf = [];\n    let gap;\n\n    /*\n     * Gap 1/3 (40/0x28 bytes)\n     */\n\n    if (sector === 0)\n        // Gap 1\n        gap = 0x80;\n    else {\n        // Gap 3\n        gap = track === 0 ? 0x28 : 0x26;\n    }\n\n    for (let idx = 0; idx < gap; idx++) {\n        buf.push(0xff);\n    }\n\n    /*\n     * Address Field\n     */\n\n    const checksum = volume ^ track ^ sector;\n    buf = buf.concat([0xd5, 0xaa, 0xb5]); // Address Prolog D5 AA B5\n    buf = buf.concat(fourXfour(volume));\n    buf = buf.concat(fourXfour(track));\n    buf = buf.concat(fourXfour(sector));\n    buf = buf.concat(fourXfour(checksum));\n    buf = buf.concat([0xde, 0xaa, 0xeb]); // Epilog DE AA EB\n\n    /*\n     * Gap 2 (5 bytes)\n     */\n\n    for (let idx = 0; idx < 0x05; idx++) {\n        buf.push(0xff);\n    }\n\n    /*\n     * Data Field\n     */\n\n    buf = buf.concat([0xd5, 0xaa, 0xad]); // Data Prolog D5 AA AD\n\n    const nibbles = [];\n\n    let jdx = 0;\n    for (let idx = 0x32; idx >= 0; idx--) {\n        const a5 = data[jdx] >> 3;\n        const a3 = data[jdx] & 0x07;\n        jdx++;\n        const b5 = data[jdx] >> 3;\n        const b3 = data[jdx] & 0x07;\n        jdx++;\n        const c5 = data[jdx] >> 3;\n        const c3 = data[jdx] & 0x07;\n        jdx++;\n        const d5 = data[jdx] >> 3;\n        const d3 = data[jdx] & 0x07;\n        jdx++;\n        const e5 = data[jdx] >> 3;\n        const e3 = data[jdx] & 0x07;\n        jdx++;\n        nibbles[idx + 0x00] = a5;\n        nibbles[idx + 0x33] = b5;\n        nibbles[idx + 0x66] = c5;\n        nibbles[idx + 0x99] = d5;\n        nibbles[idx + 0xcc] = e5;\n        nibbles[idx + 0x100] =\n            (a3 << 2) | ((d3 & 0x4) >> 1) | ((e3 & 0x4) >> 2);\n        nibbles[idx + 0x133] = (b3 << 2) | (d3 & 0x2) | ((e3 & 0x2) >> 1);\n        nibbles[idx + 0x166] = (c3 << 2) | ((d3 & 0x1) << 1) | (e3 & 0x1);\n    }\n    nibbles[0xff] = data[jdx] >> 3;\n    nibbles[0x199] = data[jdx] & 0x07;\n\n    let last = 0;\n    for (let idx = 0x199; idx >= 0x100; idx--) {\n        const val = nibbles[idx];\n        buf.push(TRANS53[last ^ val]);\n        last = val;\n    }\n    for (let idx = 0x0; idx < 0x100; idx++) {\n        const val = nibbles[idx];\n        buf.push(TRANS53[last ^ val]);\n        last = val;\n    }\n    buf.push(TRANS53[last]);\n\n    buf = buf.concat([0xde, 0xaa, 0xeb]); // Epilog DE AA EB\n\n    /*\n     * Gap 3\n     */\n\n    buf.push(0xff);\n\n    return buf;\n}\n\nexport interface TrackNibble {\n    track: byte;\n    sector: byte;\n    nibble: byte;\n    sectors: SupportedSectors;\n}\n\nenum LookingFor {\n    START_OF_FIELD_MARKER_FIRST_NIBBLE,\n    START_OF_FIELD_MARKER_SECOND_NIBBLE,\n    FIELD_TYPE_MARKER,\n    ADDRESS_FIELD,\n    ADDRESS_FIELD_13,\n    DATA_FIELD_6AND2,\n    DATA_FIELD_5AND3,\n}\n\nexport class FindSectorError extends Error {\n    constructor(track: byte, sector: byte, e: unknown) {\n        super(\n            `Error finding track ${track} (${toHex(\n                track\n            )}), sector ${sector} (${toHex(sector)}): ` +\n                (e instanceof Error ? `${e.message}` : `${String(e)}`)\n        );\n    }\n}\n\n/**\n * Finds a sector of data from a nibblized disk. The sector given should be the\n * \"physical\" sector number, meaning the one that appears in the address field.\n * The first sector with the right sector number and data whose checksum matches\n * is returned. This means that for a dual-boot disk (DOS 3.2 and DOS 3.3),\n * whichever sector is found first wins.\n *\n * @param disk Nibble disk\n * @param track track number to read\n * @param sector sector number to read\n * @returns the track, sector, nibble offset, and detected sectors\n */\nexport function findSector(\n    disk: NibbleDisk,\n    track: byte,\n    sector: byte\n): TrackNibble {\n    const cur = disk.tracks[track];\n    let sectors: SupportedSectors = 16;\n    let state = LookingFor.START_OF_FIELD_MARKER_FIRST_NIBBLE;\n    let idx = 0;\n    let retry = 0;\n\n    function _readNext() {\n        const result = cur[idx++];\n        if (idx >= cur.length) {\n            idx = 0;\n            retry++;\n        }\n        return result;\n    }\n    function _skipBytes(count: number) {\n        idx += count;\n        if (idx >= cur.length) {\n            idx %= cur.length;\n            retry++;\n        }\n    }\n    let t = 0,\n        s = 0,\n        v = 0,\n        checkSum;\n    while (retry < 4) {\n        let val: byte;\n        switch (state) {\n            case LookingFor.START_OF_FIELD_MARKER_FIRST_NIBBLE:\n                val = _readNext();\n                state =\n                    val === 0xd5\n                        ? LookingFor.START_OF_FIELD_MARKER_SECOND_NIBBLE\n                        : LookingFor.START_OF_FIELD_MARKER_FIRST_NIBBLE;\n                break;\n            case LookingFor.START_OF_FIELD_MARKER_SECOND_NIBBLE:\n                val = _readNext();\n                state =\n                    val === 0xaa\n                        ? LookingFor.FIELD_TYPE_MARKER\n                        : LookingFor.START_OF_FIELD_MARKER_FIRST_NIBBLE;\n                break;\n            case LookingFor.FIELD_TYPE_MARKER:\n                val = _readNext();\n                switch (val) {\n                    case 0x96:\n                        state = LookingFor.ADDRESS_FIELD;\n                        sectors = 16;\n                        break;\n                    case 0xb5:\n                        state = LookingFor.ADDRESS_FIELD;\n                        sectors = 13;\n                        break;\n                    case 0xad:\n                        state =\n                            sectors === 16\n                                ? LookingFor.DATA_FIELD_6AND2\n                                : LookingFor.DATA_FIELD_5AND3;\n                        break;\n                    default:\n                        state = LookingFor.START_OF_FIELD_MARKER_FIRST_NIBBLE;\n                }\n                break;\n            case LookingFor.ADDRESS_FIELD:\n                v = defourXfour(_readNext(), _readNext()); // Volume\n                t = defourXfour(_readNext(), _readNext()); // Track\n                s = defourXfour(_readNext(), _readNext()); // Sector\n                checkSum = defourXfour(_readNext(), _readNext());\n                if (checkSum !== (v ^ t ^ s)) {\n                    debug(\n                        'Invalid header checksum:',\n                        toHex(v),\n                        toHex(t),\n                        toHex(s),\n                        toHex(checkSum)\n                    );\n                }\n                _skipBytes(3); // Skip footer\n                state = 0;\n                break;\n            case LookingFor.DATA_FIELD_6AND2:\n                if (s === sector && t === track) {\n                    // Save start of data\n                    const nibble = idx;\n\n                    // Do checksum on data\n                    let last = 0;\n                    for (let jdx = 0; jdx < 0x156; jdx++) {\n                        last = DETRANS62[_readNext() - 0x80] ^ last;\n                    }\n                    const checkSum = DETRANS62[_readNext() - 0x80] ^ last;\n                    // Validate checksum before returning\n                    if (!checkSum) {\n                        return { track, sector, nibble, sectors };\n                    } else {\n                        debug(\n                            'Invalid data checksum:',\n                            toHex(last),\n                            toHex(track),\n                            toHex(sector),\n                            toHex(checkSum)\n                        );\n                    }\n                    _skipBytes(3); // Skip footer\n                } else _skipBytes(0x159); // Skip data, checksum and footer\n                state = LookingFor.START_OF_FIELD_MARKER_FIRST_NIBBLE;\n                break;\n            case LookingFor.DATA_FIELD_5AND3:\n                if (s === sector && t === track) {\n                    // Save start of data\n                    const nibble = idx;\n\n                    // Do checksum on data\n                    let last = 0;\n                    for (let jdx = 0; jdx < 0x19a; jdx++) {\n                        last = DETRANS53[_readNext() - 0xa0] ^ last;\n                    }\n                    const checkSum = DETRANS53[_readNext() - 0xa0] ^ last;\n                    // Validate checksum before returning\n                    if (!checkSum) {\n                        return { track, sector, nibble, sectors };\n                    } else {\n                        debug(\n                            'Invalid data checksum:',\n                            toHex(last),\n                            toHex(track),\n                            toHex(sector),\n                            toHex(checkSum)\n                        );\n                    }\n                    _skipBytes(3); // Skip footer\n                } else {\n                    _skipBytes(0x19a); // Skip data, checksum and footer\n                }\n                state = LookingFor.START_OF_FIELD_MARKER_FIRST_NIBBLE;\n                break;\n            default:\n                state = LookingFor.START_OF_FIELD_MARKER_FIRST_NIBBLE;\n                break;\n        }\n    }\n    throw new FindSectorError(track, sector, `too many retries (${retry})`);\n}\n\nexport class InvalidChecksum extends Error {\n    constructor(expected: byte, received: byte) {\n        super(`Expected: ${toHex(expected)}, received: ${toHex(received)}`);\n    }\n}\n\nexport class ReadSectorError extends Error {\n    constructor(track: byte, sector: byte, e: unknown) {\n        super(\n            `Error reading track ${track} (${toHex(\n                track\n            )}), sector ${sector} (${toHex(sector)}): ` +\n                (e instanceof Error ? `${e.message}` : `${String(e)}`)\n        );\n    }\n}\n\n/**\n * Reads a sector of data from a nibblized disk. The sector given should be the\n * \"physical\" sector number, meaning the one that appears in the address field.\n * Like `findSector`, the first sector with the right sector number and data\n * whose checksum matches is returned. This means that for a dual-boot disk\n * (DOS 3.2 and DOS 3.3), whichever sector is found first wins.\n *\n * This does not work for WOZ disks.\n *\n * If the given track and sector combination is not found, a `ReadSectorError`\n * will be thrown.\n *\n * @param disk Nibble disk\n * @param track track number to read\n * @param sector sector number to read\n * @returns An array of sector data bytes.\n */\nexport function readSector(\n    disk: NibbleDisk,\n    track: byte,\n    sector: byte\n): Uint8Array {\n    const trackNibble = findSector(disk, track, sector);\n    const { nibble, sectors } = trackNibble;\n    const cur = disk.tracks[track];\n\n    let idx = nibble;\n    const _readNext = () => {\n        const result = cur[idx++];\n        if (idx >= cur.length) {\n            idx = 0;\n        }\n        return result;\n    };\n\n    try {\n        return sectors === 13\n            ? readSector13(_readNext)\n            : readSector16(_readNext);\n    } catch (e: unknown) {\n        throw new ReadSectorError(track, sector, e);\n    }\n}\n\nfunction readSector16(_readNext: () => byte): Uint8Array {\n    const data = new Uint8Array(256);\n    const data2 = [];\n    let last: byte = 0;\n    let val;\n\n    for (let jdx = 0x55; jdx >= 0; jdx--) {\n        val = DETRANS62[_readNext() - 0x80] ^ last;\n        data2[jdx] = val;\n        last = val;\n    }\n    for (let jdx = 0; jdx < 0x100; jdx++) {\n        val = DETRANS62[_readNext() - 0x80] ^ last;\n        data[jdx] = val;\n        last = val;\n    }\n    const checkSum = DETRANS62[_readNext() - 0x80] ^ last;\n    if (checkSum) {\n        throw new InvalidChecksum(last, checkSum ^ last);\n    }\n    for (let kdx = 0, jdx = 0x55; kdx < 0x100; kdx++) {\n        data[kdx] <<= 1;\n        if ((data2[jdx] & 0x01) !== 0) {\n            data[kdx] |= 0x01;\n        }\n        data2[jdx] >>= 1;\n\n        data[kdx] <<= 1;\n        if ((data2[jdx] & 0x01) !== 0) {\n            data[kdx] |= 0x01;\n        }\n        data2[jdx] >>= 1;\n\n        if (--jdx < 0) jdx = 0x55;\n    }\n    return data;\n}\n\nfunction readSector13(_readNext: () => byte) {\n    const data = new Uint8Array(256);\n    let val: byte;\n    let last: byte = 0;\n\n    // special low 3-bits of 0xFF\n    val = DETRANS53[_readNext() - 0xa0] ^ last;\n    last = val;\n    data[0xff] = val & 0b111;\n\n    // expect 0x99 nibbles of packed lower 3-bits in reverse order\n    for (let i = 0x98; i >= 0x00; i--) {\n        val = DETRANS53[_readNext() - 0xa0] ^ last;\n        last = val;\n        const off = Math.floor(i / 0x33) + 5 * (0x32 - (i % 0x33));\n        const dOff = 3 + 5 * (0x32 - (i % 0x33));\n        const eOff = 4 + 5 * (0x32 - (i % 0x33));\n        const bit = 2 - Math.floor(i / 0x33);\n        data[off] = (val & 0b11100) >> 2;\n        data[dOff] ^= ((val & 0b00010) >> 1) << bit;\n        data[eOff] ^= (val & 0b1) << bit;\n    }\n\n    // expect 0xFE nibbles of upper 5-bits\n    for (let i = 0; i < 0xff; i++) {\n        val = DETRANS53[_readNext() - 0xa0] ^ last;\n        last = val;\n        const off = Math.floor(i / 0x33) + 5 * (0x32 - (i % 0x33));\n        data[off] ^= val << 3;\n    }\n\n    // and the last special nibble for 0xFF\n    val = DETRANS53[_readNext() - 0xa0] ^ last;\n    last = val;\n    data[0xff] ^= val << 3;\n\n    const checkSum = DETRANS53[_readNext() - 0xa0] ^ last;\n    if (checkSum) {\n        throw new InvalidChecksum(last, checkSum ^ last);\n    }\n    return data;\n}\n\n/**\n * Reads a sector of data from a nibblized disk\n *\n * TODO(flan): Does not work on WOZ disks\n *\n * @param disk Nibble disk\n * @param track track number to read\n * @param sector sector number to read\n * @returns An array of sector data bytes.\n */\nexport function writeSector(\n    disk: NibbleDisk,\n    track: byte,\n    sector: byte,\n    _data: Uint8Array\n): boolean {\n    const trackNibble = findSector(disk, track, sector);\n    if (!trackNibble) {\n        return false;\n    }\n\n    // Todo\n\n    return true;\n}\n\n/**\n * Convert a nibblized disk into a JSON string for storage.\n *\n * @param disk Nibblized disk\n * @param pretty Whether to format the output string\n * @returns A JSON string representing the disk\n */\nexport function jsonEncode(disk: NibbleDisk, pretty: boolean): string {\n    // For 'nib', tracks are encoded as strings. For all other formats,\n    // tracks are arrays of sectors which are encoded as strings.\n    const data: string[] | string[][] = [];\n    let format = 'dsk';\n    for (let t = 0; t < disk.tracks.length; t++) {\n        data[t] = [];\n        if (disk.format === 'nib') {\n            format = 'nib';\n            data[t] = base64_encode(disk.tracks[t]);\n        } else {\n            for (let s = 0; s < 0x10; s++) {\n                const _sector = disk.format === 'po' ? _PO[s] : _DO[s];\n                (data[t] as string[])[s] = base64_encode(\n                    readSector(disk, t, _sector)\n                );\n            }\n        }\n    }\n    return JSON.stringify(\n        {\n            type: format,\n            encoding: 'base64',\n            volume: disk.volume,\n            data: data,\n            readOnly: disk.readOnly,\n        },\n        undefined,\n        pretty ? '    ' : undefined\n    );\n}\n\n/**\n * Convert a JSON string into a nibblized disk.\n *\n * @param data JSON string representing a disk image, created by [jsonEncode].\n * @returns A nibblized disk\n */\n\nexport function jsonDecode(data: string): NibbleDisk {\n    const tracks: memory[] = [];\n    const json = JSON.parse(data) as JSONDisk;\n    const v = json.volume || 254;\n    const readOnly = json.readOnly || false;\n    for (let t = 0; t < json.data.length; t++) {\n        let track: byte[] = [];\n        for (let s = 0; s < json.data[t].length; s++) {\n            const _s = json.type === 'po' ? PO[s] : DO[s];\n            const sector: string = json.data[t][_s] as string;\n            const d = base64_decode(sector);\n            track = track.concat(explodeSector16(v, t, s, d));\n        }\n        tracks[t] = bytify(track);\n    }\n    if (!isNibbleDiskFormat(json.type)) {\n        throw new Error(`JSON disks of type ${json.type} are not supported`);\n    }\n    const disk: NibbleDisk = {\n        volume: v,\n        format: json.type,\n        encoding: ENCODING_NIBBLE,\n        metadata: { name: json.name },\n        tracks,\n        readOnly,\n    };\n\n    return disk;\n}\n\n/**\n * Debugging method that displays the logical sector ordering of a nibblized disk\n *\n * @param disk\n */\n\nexport function analyseDisk(disk: NibbleDisk) {\n    for (let track = 0; track < disk.tracks.length; track++) {\n        let outStr = `${toHex(track)}: `;\n        let val,\n            state = 0;\n        let idx = 0;\n        const cur = disk.tracks[track];\n\n        const _readNext = () => {\n            const result = cur[idx++];\n            return result;\n        };\n\n        const _skipBytes = (count: number) => {\n            idx += count;\n        };\n\n        let t = 0,\n            s = 0,\n            v = 0,\n            checkSum;\n        while (idx < cur.length) {\n            switch (state) {\n                case 0:\n                    val = _readNext();\n                    state = val === 0xd5 ? 1 : 0;\n                    break;\n                case 1:\n                    val = _readNext();\n                    state = val === 0xaa ? 2 : 0;\n                    break;\n                case 2:\n                    val = _readNext();\n                    state = val === 0x96 ? 3 : val === 0xad ? 4 : 0;\n                    break;\n                case 3: // Address\n                    v = defourXfour(_readNext(), _readNext()); // Volume\n                    t = defourXfour(_readNext(), _readNext());\n                    s = defourXfour(_readNext(), _readNext());\n                    checkSum = defourXfour(_readNext(), _readNext());\n                    if (checkSum !== (v ^ t ^ s)) {\n                        debug(\n                            'Invalid header checksum:',\n                            toHex(v),\n                            toHex(t),\n                            toHex(s),\n                            toHex(checkSum)\n                        );\n                    } else {\n                        outStr += toHex(s, 1);\n                    }\n                    _skipBytes(3); // Skip footer\n                    state = 0;\n                    break;\n                case 4: // Valid header\n                    _skipBytes(0x159); // Skip data, checksum and footer\n                    state = 0;\n                    break;\n                default:\n                    break;\n            }\n        }\n        debug(outStr);\n    }\n}\n\n/**\n * Debugging utility to convert a bitstream into a nibble. Does not wrap.\n *\n * @param bits Bitstream containing nibbles\n * @param offset Offset into bitstream to start nibblizing\n * @returns nibble, the next nibble in the bitstream,\n *      and offset, the end of that nibble in the bitstream\n */\n\nexport function grabNibble(bits: bit[], offset: number) {\n    let nibble = 0;\n    let waitForOne = true;\n\n    while (offset < bits.length) {\n        const bit = bits[offset];\n        if (bit) {\n            nibble = (nibble << 1) | 0x01;\n            waitForOne = false;\n        } else {\n            if (!waitForOne) {\n                nibble = nibble << 1;\n            }\n        }\n        if (nibble & 0x80) {\n            // nibble complete return it\n            break;\n        }\n        offset += 1;\n    }\n\n    return {\n        nibble: nibble,\n        offset: offset,\n    };\n}\n","import { explodeSector16, DO } from './format_utils';\nimport { bytify } from '../util';\nimport { byte } from '../types';\nimport { NibbleDisk, DiskOptions, ENCODING_NIBBLE } from './types';\n\n/**\n * Returns a `Disk` object from DOS-ordered image data.\n * @param options the disk image and options\n * @returns A nibblized disk\n */\nexport default function createDiskFromDOS(options: DiskOptions): NibbleDisk {\n    const { data, name, side, rawData, volume, readOnly } = options;\n    const disk: NibbleDisk = {\n        format: 'dsk',\n        encoding: ENCODING_NIBBLE,\n        metadata: { name, side },\n        volume,\n        readOnly,\n        tracks: [],\n    };\n\n    for (let t = 0; t < 35; t++) {\n        let track: byte[] = [];\n        for (let physical_sector = 0; physical_sector < 16; physical_sector++) {\n            const dos_sector = DO[physical_sector];\n            let sector: Uint8Array;\n            if (rawData) {\n                const off = (16 * t + dos_sector) * 256;\n                sector = new Uint8Array(rawData.slice(off, off + 256));\n            } else if (data) {\n                sector = new Uint8Array(data[t][dos_sector]);\n            } else {\n                throw new Error('Requires data or rawData');\n            }\n            track = track.concat(\n                explodeSector16(volume, t, physical_sector, sector)\n            );\n        }\n        disk.tracks[t] = bytify(track);\n    }\n    return disk;\n}\n","import { NibbleDisk, DiskOptions, ENCODING_NIBBLE } from './types';\nimport { memory } from '../types';\n\n/**\n * Returns a `Disk` object from raw nibble image data.\n * @param options the disk image and options\n * @returns A nibblized disk\n */\nexport default function createDiskFromNibble(options: DiskOptions): NibbleDisk {\n    const { data, name, side, rawData, volume, readOnly } = options;\n    const disk: NibbleDisk = {\n        format: 'nib',\n        encoding: ENCODING_NIBBLE,\n        metadata: { name, side },\n        volume: volume || 254,\n        readOnly: readOnly || false,\n        tracks: [],\n    };\n\n    for (let t = 0; t < 35; t++) {\n        let track: memory;\n        if (rawData) {\n            const off = t * 0x1a00;\n            track = new Uint8Array(rawData.slice(off, off + 0x1a00));\n        } else if (data) {\n            track = data[t][0];\n        } else {\n            throw new Error('Requires data or rawData');\n        }\n        disk.tracks[t] = track;\n    }\n\n    return disk;\n}\n","import { byte } from 'js/types';\n\nexport const BLOCK_SIZE = 512;\n\nexport const STORAGE_TYPES = {\n    DELETED: 0x0,\n    SEEDLING: 0x1,\n    SAPLING: 0x2,\n    TREE: 0x3,\n    PASCAL: 0x4,\n    EXTENDED: 0x5,\n    DIRECTORY: 0xd,\n    SUBDIRECTORY_HEADER: 0xe,\n    VDH_HEADER: 0xf,\n} as const;\n\nexport const ACCESS_TYPES = {\n    DELETE: 0x80,\n    RENAME: 0x40,\n    BACKUP: 0x20,\n    WRITE: 0x02,\n    READ: 0x01,\n    ALL: 0xe3,\n} as const;\n\nexport const FILE_TYPES: Record<byte, string> = {\n    0x00: 'UNK', // Typeless file (SOS and ProDOS)\n    0x01: 'BAD', // Bad block file\n    0x02: 'PDC', // Pascal code file\n    0x03: 'PTX', // Pascal text file\n    0x04: 'TXT', // ASCII text file (SOS and ProDOS)\n    0x05: 'PDA', // Pascal data file\n    0x06: 'BIN', // General binary file (SOS and ProDOS)\n    0x07: 'FNT', // Font file\n    0x08: 'FOT', // Graphics screen file\n    0x09: 'BA3', // Business BASIC program file\n    0x0a: 'DA3', // Business BASIC data file\n    0x0b: 'WPF', // Word Processor file\n    0x0c: 'SOS', // SOS system file\n    0x0f: 'DIR', // Directory file (SOS and ProDOS)\n    0x10: 'RPD', // RPS data file\n    0x11: 'RPI', // RPS index file\n    0x12: 'AFD', // AppleFile discard file\n    0x13: 'AFM', // AppleFile model file\n    0x14: 'ARF', // AppleFile report format file\n    0x15: 'SCL', // Screen Library file\n    0x19: 'ADB', // AppleWorks Data Base file\n    0x1a: 'AWP', // AppleWorks Word Processor file\n    0x1b: 'ASP', // AppleWorks Spreadsheet file\n    0xef: 'PAR', // Pascal area\n    0xf0: 'CMD', // ProDOS CI added command file\n    0xfa: 'INT', // Integer BASIC program file\n    0xfb: 'IVR', // Integer BASIC variable file\n    0xfc: 'BAS', // Applesoft program file\n    0xfd: 'VAR', // Applesoft variables file\n    0xfe: 'REL', // Relocatable code file (EDASM)\n    0xff: 'SYS', // ProDOS system file\n} as const;\n","import { explodeSector16, PO } from './format_utils';\nimport { bytify } from '../util';\nimport type { byte } from '../types';\nimport {\n    NibbleDisk,\n    DiskOptions,\n    ENCODING_NIBBLE,\n    BlockDisk,\n    FloppyDisk,\n    MemoryBlockDisk,\n} from './types';\nimport { BLOCK_SIZE } from './prodos/constants';\n\n/**\n * Returns a `Disk` object from ProDOS-ordered image data.\n * @param options the disk image and options\n * @returns A nibblized disk\n */\nexport default function createDiskFromProDOS(\n    options: DiskOptions\n): BlockDisk | FloppyDisk {\n    const { data, name, side, rawData, volume, readOnly } = options;\n    let disk: BlockDisk | NibbleDisk;\n    if (rawData && rawData.byteLength > 140 * 1025) {\n        const blocks: Uint8Array[] = [];\n        for (\n            let offset = 0;\n            offset < rawData.byteLength;\n            offset += BLOCK_SIZE\n        ) {\n            blocks.push(\n                new Uint8Array(rawData.slice(offset, offset + BLOCK_SIZE))\n            );\n        }\n        disk = new MemoryBlockDisk(\n            'po',\n            { name, side },\n            readOnly || false,\n            blocks\n        );\n    } else {\n        disk = {\n            format: 'po',\n            encoding: ENCODING_NIBBLE,\n            metadata: { name, side },\n            volume: volume || 254,\n            tracks: [],\n            readOnly: readOnly || false,\n        } as NibbleDisk;\n\n        for (let physical_track = 0; physical_track < 35; physical_track++) {\n            let track: byte[] = [];\n            for (\n                let physical_sector = 0;\n                physical_sector < 16;\n                physical_sector++\n            ) {\n                const prodos_sector = PO[physical_sector];\n                let sector;\n                if (rawData) {\n                    const off = (16 * physical_track + prodos_sector) * 256;\n                    sector = new Uint8Array(rawData.slice(off, off + 256));\n                } else if (data) {\n                    sector = data[physical_track][prodos_sector];\n                } else {\n                    throw new Error('Requires data or rawData');\n                }\n                track = track.concat(\n                    explodeSector16(\n                        volume,\n                        physical_track,\n                        physical_sector,\n                        sector\n                    )\n                );\n            }\n            disk.tracks[physical_track] = bytify(track);\n        }\n    }\n\n    return disk;\n}\n","import DOS from './do';\nimport Nibble from './nib';\nimport ProDOS from './po';\nimport { BlockDisk, DiskOptions } from './types';\n\nimport { byte, ReadonlyUint8Array } from 'js/types';\n\n/**\n * Offsets in bytes to the various header fields. All number fields are\n * in little-endian order (least significant byte first). These values\n * come from the spec at:\n *\n * https://apple2.org.za/gswv/a2zine/Docs/DiskImage_2MG_Info.txt\n */\nconst OFFSETS = {\n    /** File signature ('2IMG', 4 bytes) */\n    SIGNATURE: 0x00,\n    /** Creator ID (4 bytes) */\n    CREATOR: 0x04,\n    /** Header length (2 bytes) */\n    HEADER_LENGTH: 0x08,\n    /** Version number (2 bytes). (Version of what? Format? Image?). */\n    VERSION: 0x0a,\n    /** Image format ID (4 bytes) */\n    FORMAT: 0x0c,\n    /** Flags and DOS 3.3 volume number */\n    FLAGS: 0x10,\n    /**\n     * Number of ProDOS blocks (4 bytes). ProDOS blocks are 512 bytes each.\n     * This field must be zero if the image format is not 0x01 (ProDOS).\n     * (ASIMOV2 always fills in this field.)\n     */\n    BLOCKS: 0x14,\n    /**\n     * Disk data start in bytes from the beginning of the image file\n     * (4 bytes).\n     */\n    DATA_OFFSET: 0x18,\n    /**\n     * Length of disk data in bytes (4 bytes). (143,360 bytes for 5.25\"\n     * floppies; 512  blocks for ProDOS volumes.)\n     */\n    DATA_LENGTH: 0x1c,\n    /**\n     * Comment start in bytes from the beginning of the image file (4 bytes).\n     * Must be zero if there is no comment. The comment must come after the\n     * disk data and before the creator data. The comment should be \"raw text\"\n     * with no terminating null. By \"raw text\", we assume UTF-8.\n     */\n    COMMENT: 0x20,\n    /**\n     * Comment length in bytes (4 bytes). Must be zero if there is no comment.\n     */\n    COMMENT_LENGTH: 0x24,\n    /**\n     * Optional creator data start in bytes from the beginning of the image\n     * file (4 bytes). Must be zero if there is no creator data.\n     */\n    CREATOR_DATA: 0x28,\n    /**\n     * Creator data length in bytes (4 bytes). Must be zero if there is no\n     * creator data.\n     */\n    CREATOR_DATA_LENGTH: 0x2c,\n    /** Padding (16 bytes). Must be zero. */\n    PADDING: 0x30,\n} as const;\n\nconst FLAGS = {\n    READ_ONLY: 0x80000000,\n    VOLUME_VALID: 0x00000100,\n    VOLUME_MASK: 0x000000ff,\n} as const;\n\nexport enum FORMAT {\n    DOS = 0,\n    ProDOS = 1,\n    NIB = 2,\n}\n\nexport interface HeaderData {\n    bytes: number;\n    creator: string;\n    format: FORMAT;\n    offset: number;\n    readOnly: boolean;\n    volume: byte;\n    comment?: string;\n    creatorData?: ReadonlyUint8Array;\n}\n\nexport function read2MGHeader(rawData: ArrayBuffer): HeaderData {\n    const prefix = new DataView(rawData);\n    const decoder = new TextDecoder('ascii');\n    const signature = decoder.decode(\n        rawData.slice(OFFSETS.SIGNATURE, OFFSETS.SIGNATURE + 4)\n    );\n    if (signature !== '2IMG') {\n        throw new Error(`Unrecognized 2mg signature: ${signature}`);\n    }\n    const creator = decoder.decode(\n        rawData.slice(OFFSETS.CREATOR, OFFSETS.CREATOR + 4)\n    );\n    const headerLength = prefix.getInt16(OFFSETS.HEADER_LENGTH, true);\n    if (headerLength !== 64) {\n        throw new Error(\n            `2mg header length is incorrect ${headerLength} !== 64`\n        );\n    }\n    const format = prefix.getInt32(OFFSETS.FORMAT, true) as FORMAT;\n    const flags = prefix.getInt32(OFFSETS.FLAGS, true);\n    const blocks = prefix.getInt32(OFFSETS.BLOCKS, true);\n    const offset = prefix.getInt32(OFFSETS.DATA_OFFSET, true);\n    const bytes = prefix.getInt32(OFFSETS.DATA_LENGTH, true);\n    const commentOffset = prefix.getInt32(OFFSETS.COMMENT, true);\n    const commentLength = prefix.getInt32(OFFSETS.COMMENT_LENGTH, true);\n    const creatorDataOffset = prefix.getInt32(OFFSETS.CREATOR_DATA, true);\n    const creatorDataLength = prefix.getInt32(\n        OFFSETS.CREATOR_DATA_LENGTH,\n        true\n    );\n\n    // Though the spec says that it should be zero if the format is not\n    // ProDOS, we don't check that since we know that it is violated.\n    // However we do check that it's correct if the image _is_ ProDOS.\n    if (format === FORMAT.ProDOS && blocks * 512 !== bytes) {\n        throw new Error(\n            `2mg blocks does not match disk data length: ${blocks} * 512 !== ${bytes}`\n        );\n    }\n    if (offset < headerLength) {\n        throw new Error(\n            `2mg data offset is less than header length: ${offset} < ${headerLength}`\n        );\n    }\n    if (offset + bytes > prefix.byteLength) {\n        throw new Error(\n            `2mg data extends beyond disk image: ${offset} + ${bytes} > ${prefix.byteLength}`\n        );\n    }\n    const dataEnd = offset + bytes;\n    if (commentOffset && commentOffset < dataEnd) {\n        throw new Error(\n            `2mg comment is before the end of the disk data: ${commentOffset} < ${offset} + ${bytes}`\n        );\n    }\n    const commentEnd = commentOffset ? commentOffset + commentLength : dataEnd;\n    if (commentEnd > prefix.byteLength) {\n        throw new Error(\n            `2mg comment extends beyond disk image: ${commentEnd} > ${prefix.byteLength}`\n        );\n    }\n    if (creatorDataOffset && creatorDataOffset < commentEnd) {\n        throw new Error(\n            `2mg creator data is before the end of the comment: ${creatorDataOffset} < ${commentEnd}`\n        );\n    }\n    const creatorDataEnd = creatorDataOffset\n        ? creatorDataOffset + creatorDataLength\n        : commentEnd;\n    if (creatorDataEnd > prefix.byteLength) {\n        throw new Error(\n            `2mg creator data extends beyond disk image: ${creatorDataEnd} > ${prefix.byteLength}`\n        );\n    }\n\n    const extras: { comment?: string; creatorData?: ReadonlyUint8Array } = {};\n    if (commentOffset) {\n        extras.comment = new TextDecoder('utf-8').decode(\n            new Uint8Array(rawData, commentOffset, commentLength)\n        );\n    }\n    if (creatorDataOffset) {\n        extras.creatorData = new Uint8Array(\n            rawData,\n            creatorDataOffset,\n            creatorDataLength\n        );\n    }\n\n    const readOnly = (flags & FLAGS.READ_ONLY) !== 0;\n    let volume = format === FORMAT.DOS ? 254 : 0;\n    if (flags & FLAGS.VOLUME_VALID) {\n        volume = flags & FLAGS.VOLUME_MASK;\n    }\n\n    return {\n        bytes,\n        creator,\n        format,\n        offset,\n        readOnly,\n        volume,\n        ...extras,\n    };\n}\n\n/**\n * Creates the prefix and suffix parts of a 2mg file. Will use\n * default header values if headerData is null.\n *\n * Currently only supports blocks disks but should be adaptable\n * for nibble formats.\n *\n * @param headerData 2mg header data\n * @param blocks The number of blocks in a block volume\n * @returns 2mg prefix and suffix for creating a 2mg disk image\n */\n\nexport const create2MGFragments = (\n    headerData: HeaderData | null,\n    { blocks }: { blocks: number }\n) => {\n    if (!headerData) {\n        headerData = {\n            bytes: blocks * 512,\n            creator: 'A2JS',\n            format: FORMAT.ProDOS,\n            offset: 64,\n            readOnly: false,\n            volume: 0,\n        };\n    }\n    if (headerData.format !== FORMAT.ProDOS) {\n        throw new Error('Nibble formats not supported yet');\n    }\n    if (headerData.bytes !== blocks * 512) {\n        throw new Error('Byte count does not match block count');\n    }\n    const prefix = new Uint8Array(64);\n    const prefixView = new DataView(prefix.buffer);\n\n    const volumeFlags = headerData.volume\n        ? headerData.volume | FLAGS.VOLUME_VALID\n        : 0;\n    const readOnlyFlag = headerData.readOnly ? FLAGS.READ_ONLY : 0;\n    const flags = volumeFlags | readOnlyFlag;\n    const prefixLength = prefix.length;\n    const dataLength = blocks * 512;\n\n    let commentOffset = 0;\n    let commentLength = 0;\n    let commentData = new Uint8Array(0);\n    if (headerData.comment) {\n        commentData = new TextEncoder().encode(headerData.comment);\n        commentOffset = prefixLength + dataLength;\n        commentLength = commentData.length;\n    }\n    let creatorDataOffset = 0;\n    let creatorDataLength = 0;\n    let creatorData = new Uint8Array(0);\n    if (headerData.creatorData) {\n        creatorData = new Uint8Array(headerData.creatorData);\n        creatorDataOffset = prefixLength + dataLength + commentLength;\n        creatorDataLength = headerData.creatorData.length;\n    }\n\n    const encoder = new TextEncoder();\n\n    prefix.set(encoder.encode('2IMG'), OFFSETS.SIGNATURE);\n    prefix.set(encoder.encode(headerData.creator.slice(0, 4)), OFFSETS.CREATOR);\n    prefixView.setInt32(OFFSETS.HEADER_LENGTH, 64, true);\n    prefixView.setInt16(OFFSETS.VERSION, 1, true);\n    prefixView.setInt32(OFFSETS.FORMAT, headerData.format, true);\n    prefixView.setInt32(OFFSETS.FLAGS, flags, true);\n    prefixView.setInt32(OFFSETS.BLOCKS, blocks, true);\n    prefixView.setInt32(OFFSETS.DATA_OFFSET, prefixLength, true);\n    prefixView.setInt32(OFFSETS.DATA_LENGTH, dataLength, true);\n    prefixView.setInt32(OFFSETS.COMMENT, commentOffset, true);\n    prefixView.setInt32(OFFSETS.COMMENT_LENGTH, commentLength, true);\n    prefixView.setInt32(OFFSETS.CREATOR_DATA, creatorDataOffset, true);\n    prefixView.setInt32(OFFSETS.CREATOR_DATA_LENGTH, creatorDataLength, true);\n\n    const suffix = new Uint8Array(commentLength + creatorDataLength);\n    suffix.set(commentData);\n    suffix.set(creatorData, commentLength);\n\n    return { prefix, suffix };\n};\n\n/**\n * Creates a 2MG image from stored 2MG header data and a block disk. Will use\n * default header values if headerData is null.\n *\n * @param headerData 2MG style header data\n * @param blocks Prodos volume blocks\n * @returns 2MS\n */\n\nexport const create2MGFromBlockDisk = async (\n    headerData: HeaderData | null,\n    disk: BlockDisk\n): Promise<ArrayBuffer> => {\n    const blockCount = await disk.blockCount();\n    const { prefix, suffix } = create2MGFragments(headerData, {\n        blocks: blockCount,\n    });\n\n    const imageLength = prefix.length + blockCount * 512 + suffix.length;\n    const byteArray = new Uint8Array(imageLength);\n    byteArray.set(prefix);\n    for (let idx = 0; idx < blockCount; idx++) {\n        const block = await disk.read(idx);\n        byteArray.set(block, prefix.length + idx * 512);\n    }\n    byteArray.set(suffix, prefix.length + blockCount * 512);\n\n    return byteArray.buffer;\n};\n\n/**\n * Returns a `Disk` object from a 2mg image.\n * @param options the disk image and options\n */\nexport default function createDiskFrom2MG(options: DiskOptions) {\n    let { rawData } = options;\n    let disk;\n\n    if (!rawData) {\n        throw new Error('Requires rawData');\n    }\n\n    const { bytes, format, offset, readOnly, volume } = read2MGHeader(rawData);\n    rawData = rawData.slice(offset, offset + bytes);\n    options = { ...options, rawData, readOnly, volume };\n\n    // Check image format.\n    // Sure, it's really 64 bits. But only 2 are actually used.\n    switch (format) {\n        case FORMAT.ProDOS: // PO\n            disk = ProDOS(options);\n            break;\n        case FORMAT.NIB: // NIB\n            disk = Nibble(options);\n            break;\n        case FORMAT.DOS: // dsk\n        default: // Something hinky, assume 'dsk'\n            disk = DOS(options);\n            break;\n    }\n\n    return disk;\n}\n","import { debug, toHex } from '../util';\nimport { bit, byte, word } from '../types';\nimport { grabNibble } from './format_utils';\nimport { DiskOptions, ENCODING_BITSTREAM, WozDisk } from './types';\n\nconst WOZ_HEADER_START = 0;\nconst WOZ_HEADER_SIZE = 12;\n\nconst WOZ1_SIGNATURE = 0x315a4f57;\nconst WOZ2_SIGNATURE = 0x325a4f57;\nconst WOZ_INTEGRITY_CHECK = 0x0a0d0aff;\n\n/**\n * Converts a range of bytes from a DataView into an ASCII string\n *\n * @param data DataView containing string\n * @param start start index of string\n * @param end end index of string\n * @returns ASCII string\n */\nfunction stringFromBytes(data: DataView, start: number, end: number): string {\n    const byteArray = new Uint8Array(\n        data.buffer.slice(data.byteOffset + start, data.byteOffset + end)\n    );\n    return String.fromCharCode(...byteArray);\n}\n\nexport class InfoChunk {\n    version: byte;\n\n    // Version 1\n    diskType: byte;\n    writeProtected: byte;\n    synchronized: byte;\n    cleaned: byte;\n    creator: string;\n\n    // Version 2\n    sides: byte = 0;\n    bootSector: byte = 0;\n    bitTiming: byte = 0;\n    compatibleHardware: word = 0;\n    requiredRAM: word = 0;\n    largestTrack: word = 0;\n\n    constructor(data: DataView) {\n        this.version = data.getUint8(0);\n        this.diskType = data.getUint8(1);\n        this.writeProtected = data.getUint8(2);\n        this.synchronized = data.getUint8(3);\n        this.cleaned = data.getUint8(4);\n        this.creator = stringFromBytes(data, 5, 37);\n\n        if (this.version > 1) {\n            this.sides = data.getUint8(37);\n            this.bootSector = data.getUint8(38);\n            this.bitTiming = data.getUint8(39);\n            this.compatibleHardware = data.getUint16(40, true);\n            this.requiredRAM = data.getUint16(42, true);\n            this.largestTrack = data.getUint16(44, true);\n        }\n    }\n}\n\nexport class TMapChunk {\n    trackMap: byte[];\n\n    constructor(data: DataView) {\n        this.trackMap = [];\n\n        for (let idx = 0; idx < 160; idx++) {\n            this.trackMap.push(data.getUint8(idx));\n        }\n    }\n}\n\nconst WOZ_TRACK_SIZE = 6656;\nconst WOZ_TRACK_INFO_BITS = 6648;\n\nexport class TrksChunk {\n    rawTracks: Uint8Array[];\n    tracks: Uint8Array[];\n}\n\nexport class TrksChunk1 extends TrksChunk {\n    constructor(data: DataView) {\n        super();\n\n        this.rawTracks = [];\n        this.tracks = [];\n\n        for (\n            let trackNo = 0, idx = 0;\n            idx < data.byteLength;\n            idx += WOZ_TRACK_SIZE, trackNo++\n        ) {\n            let track = [];\n            const rawTrack: bit[] = [];\n            const slice = data.buffer.slice(\n                data.byteOffset + idx,\n                data.byteOffset + idx + WOZ_TRACK_SIZE\n            );\n            const trackData = new Uint8Array(slice);\n            const trackInfo = new DataView(slice);\n            const trackBitCount = trackInfo.getUint16(\n                WOZ_TRACK_INFO_BITS,\n                true\n            );\n            for (let jdx = 0; jdx < trackBitCount; jdx++) {\n                const byteIndex = jdx >> 3;\n                const bitIndex = 7 - (jdx & 0x07);\n                rawTrack[jdx] =\n                    (trackData[byteIndex] >> bitIndex) & 0x01 ? 1 : 0;\n            }\n\n            track = [];\n            let offset = 0;\n            while (offset < rawTrack.length) {\n                const result = grabNibble(rawTrack, offset);\n                if (!result.nibble) {\n                    break;\n                }\n                track.push(result.nibble);\n                offset = result.offset + 1;\n            }\n\n            this.tracks[trackNo] = new Uint8Array(track);\n            this.rawTracks[trackNo] = new Uint8Array(rawTrack);\n        }\n    }\n}\n\nexport interface Trk {\n    startBlock: word;\n    blockCount: word;\n    bitCount: number;\n}\n\nexport class TrksChunk2 extends TrksChunk {\n    trks: Trk[];\n\n    constructor(data: DataView) {\n        super();\n\n        let trackNo;\n        this.trks = [];\n        for (trackNo = 0; trackNo < 160; trackNo++) {\n            const startBlock = data.getUint16(trackNo * 8, true);\n            const blockCount = data.getUint16(trackNo * 8 + 2, true);\n            const bitCount = data.getUint32(trackNo * 8 + 4, true);\n            if (bitCount === 0) {\n                break;\n            }\n            this.trks.push({\n                startBlock: startBlock,\n                blockCount: blockCount,\n                bitCount: bitCount,\n            });\n        }\n        this.tracks = [];\n        this.rawTracks = [];\n\n        const bits = data.buffer;\n        for (trackNo = 0; trackNo < this.trks.length; trackNo++) {\n            const trk = this.trks[trackNo];\n\n            let track = [];\n            const rawTrack: bit[] = [];\n            const start = trk.startBlock * 512;\n            const end = start + trk.blockCount * 512;\n            const slice = bits.slice(start, end);\n            const trackData = new Uint8Array(slice);\n            if (trackNo === 0) {\n                // debug(`First bytes: ${toHex(trackData[0])} ${toHex(trackData[1])} ${toHex(trackData[2])} ${toHex(trackData[3])}`);\n            }\n            for (let jdx = 0; jdx < trk.bitCount; jdx++) {\n                const byteIndex = jdx >> 3;\n                const bitIndex = 7 - (jdx & 0x07);\n                rawTrack[jdx] =\n                    (trackData[byteIndex] >> bitIndex) & 0x01 ? 1 : 0;\n            }\n\n            track = [];\n            let offset = 0;\n            while (offset < rawTrack.length) {\n                const result = grabNibble(rawTrack, offset);\n                if (!result.nibble) {\n                    break;\n                }\n                track.push(result.nibble);\n                offset = result.offset + 1;\n            }\n\n            this.tracks[trackNo] = new Uint8Array(track);\n            this.rawTracks[trackNo] = new Uint8Array(rawTrack);\n        }\n    }\n}\n\nexport class MetaChunk {\n    values: Record<string, string>;\n\n    constructor(data: DataView) {\n        const infoStr = stringFromBytes(data, 0, data.byteLength);\n        const parts = infoStr.split('\\n');\n        this.values = parts.reduce(function (\n            acc: Record<string, string>,\n            part\n        ) {\n            const subParts = part.split('\\t');\n            acc[subParts[0]] = subParts[1];\n            return acc;\n        }, {});\n    }\n}\n\ninterface Chunks {\n    [key: string]: unknown;\n    info?: InfoChunk;\n    tmap?: TMapChunk;\n    trks?: TrksChunk;\n    meta?: MetaChunk;\n}\n\n/**\n * Returns a `Disk` object from Woz image data.\n * @param options the disk image and options\n * @returns A bitstream disk\n */\nexport default function createDiskFromWoz(options: DiskOptions): WozDisk {\n    const { rawData } = options;\n    if (!rawData) {\n        throw new Error('Requires rawData');\n    }\n    const dv = new DataView(rawData, 0);\n    let dvOffset = 0;\n    let wozVersion;\n    const chunks: Chunks = {};\n\n    function readHeader() {\n        const wozSignature = dv.getUint32(WOZ_HEADER_START + 0, true);\n\n        switch (wozSignature) {\n            case WOZ1_SIGNATURE:\n                wozVersion = 1;\n                break;\n            case WOZ2_SIGNATURE:\n                wozVersion = 2;\n                break;\n            default:\n                return false;\n        }\n\n        if (dv.getUint32(WOZ_HEADER_START + 4, true) !== WOZ_INTEGRITY_CHECK) {\n            return false;\n        }\n\n        return true;\n    }\n\n    function readChunk() {\n        if (dvOffset >= dv.byteLength) {\n            return null;\n        }\n\n        const type = dv.getUint32(dvOffset, true);\n        const size = dv.getUint32(dvOffset + 4, true);\n        const data = new DataView(dv.buffer, dvOffset + 8, size);\n        dvOffset += size + 8;\n\n        return {\n            type: type,\n            size: size,\n            data: data,\n        };\n    }\n\n    if (readHeader()) {\n        dvOffset = WOZ_HEADER_SIZE;\n        let chunk = readChunk();\n        while (chunk) {\n            switch (chunk.type) {\n                case 0x4f464e49: // INFO\n                    chunks.info = new InfoChunk(chunk.data);\n                    break;\n                case 0x50414d54: // TMAP\n                    chunks.tmap = new TMapChunk(chunk.data);\n                    break;\n                case 0x534b5254: // TRKS\n                    if (wozVersion === 1) {\n                        chunks.trks = new TrksChunk1(chunk.data);\n                    } else {\n                        chunks.trks = new TrksChunk2(chunk.data);\n                    }\n                    break;\n                case 0x4154454d: // META\n                    chunks.meta = new MetaChunk(chunk.data);\n                    break;\n                case 0x54495257: // WRIT\n                    // Ignore\n                    break;\n                default:\n                    debug('Unsupported chunk', toHex(chunk.type, 8));\n            }\n            chunk = readChunk();\n        }\n    } else {\n        debug('Invalid woz header');\n    }\n\n    // debug(chunks);\n\n    const { meta, tmap, trks, info } = chunks;\n\n    const disk: WozDisk = {\n        encoding: ENCODING_BITSTREAM,\n        format: 'woz',\n        trackMap: tmap?.trackMap || [],\n        rawTracks: trks?.rawTracks || [],\n        readOnly: true, //chunks.info.writeProtected === 1;\n        metadata: {\n            name: meta?.values['title'] || options.name,\n            side: meta?.values['side_name'] || meta?.values['side'],\n        },\n        info,\n    };\n\n    return disk;\n}\n","import { includes, memory } from '../types';\nimport { base64_decode } from '../base64';\nimport {\n    BitstreamFormat,\n    DiskOptions,\n    FloppyDisk,\n    FloppyFormat,\n    JSONDisk,\n    NibbleDisk,\n    NibbleFormat,\n    NIBBLE_FORMATS,\n    WozDisk,\n} from './types';\nimport createDiskFrom2MG from './2mg';\nimport createDiskFromD13 from './d13';\nimport createDiskFromDOS from './do';\nimport createDiskFromProDOS from './po';\nimport createDiskFromWoz from './woz';\nimport createDiskFromNibble from './nib';\n\n/** Creates a `NibbleDisk` from the given format and options. */\nexport function createDisk(\n    fmt: NibbleFormat,\n    options: DiskOptions\n): NibbleDisk | null;\n/** Creates a `WozDisk` from the given format and options. */\nexport function createDisk(\n    fmt: BitstreamFormat,\n    options: DiskOptions\n): WozDisk | null;\n/** Creates a `FloppyDisk` (either a `NibbleDisk` or a `WozDisk`) from the given format and options. */\nexport function createDisk(\n    fmt: FloppyFormat,\n    options: DiskOptions\n): FloppyDisk | null;\nexport function createDisk(\n    fmt: FloppyFormat,\n    options: DiskOptions\n): FloppyDisk | null {\n    let disk: FloppyDisk | null = null;\n\n    switch (fmt) {\n        case '2mg':\n            disk = createDiskFrom2MG(options) as FloppyDisk;\n            break;\n        case 'd13':\n            disk = createDiskFromD13(options);\n            break;\n        case 'do':\n        case 'dsk':\n            disk = createDiskFromDOS(options);\n            break;\n        case 'nib':\n            disk = createDiskFromNibble(options);\n            break;\n        case 'po':\n            disk = createDiskFromProDOS(options) as FloppyDisk;\n            break;\n        case 'woz':\n            disk = createDiskFromWoz(options);\n            break;\n    }\n\n    return disk;\n}\n\n/** Creates a NibbleDisk from JSON */\nexport function createDiskFromJsonDisk(disk: JSONDisk): NibbleDisk | null {\n    const fmt = disk.type;\n    const readOnly = disk.readOnly;\n    const name = disk.name;\n    const side = disk.disk;\n\n    if (includes(NIBBLE_FORMATS, fmt)) {\n        let trackData: memory[][];\n        if (disk.encoding === 'base64') {\n            trackData = [];\n            for (let t = 0; t < disk.data.length; t++) {\n                trackData[t] = [];\n                if (disk.type === 'nib') {\n                    trackData[t][0] = base64_decode(disk.data[t]);\n                } else {\n                    for (let s = 0; s < disk.data[t].length; s++) {\n                        trackData[t][s] = base64_decode(disk.data[t][s]);\n                    }\n                }\n            }\n        } else {\n            trackData = disk.data;\n        }\n\n        const volume = disk.volume || 0xfe;\n\n        const options = {\n            volume,\n            readOnly,\n            name,\n            side,\n            data: trackData,\n        } as DiskOptions;\n\n        return createDisk(fmt, options);\n    } else {\n        return null;\n    }\n}\n","import { explodeSector13, D13O } from './format_utils';\nimport { NibbleDisk, DiskOptions, ENCODING_NIBBLE } from './types';\n\n/**\n * Returns a `Disk` object from DOS 3.2-ordered image data.\n * @param options the disk image and options\n * @returns A nibblized disk\n */\nexport default function createDiskFromDOS13(options: DiskOptions) {\n    const { data, name, side, rawData, volume, readOnly } = options;\n    const disk: NibbleDisk = {\n        format: 'd13',\n        encoding: ENCODING_NIBBLE,\n        metadata: { name, side },\n        volume,\n        readOnly,\n        tracks: [],\n    };\n\n    if (!data && !rawData) {\n        throw new Error('data or rawData required');\n    }\n\n    /*\n     * DOS 13-sector disks have the physical sectors skewed on the track. The skew\n     * between physical sectors is 10 (A), resulting in the following physical order:\n     *\n     *   0 A 7 4 1 B 8 5 2 C 9 6 3\n     *\n     * Note that because physical sector == logical sector, this works slightly\n     * differently from the DOS and ProDOS nibblizers.\n     */\n\n    for (let t = 0; t < 35; t++) {\n        let track: number[] = [];\n        for (let disk_sector = 0; disk_sector < 13; disk_sector++) {\n            const physical_sector = D13O[disk_sector];\n            let sector: Uint8Array;\n            if (rawData) {\n                const off = (13 * t + physical_sector) * 256;\n                sector = new Uint8Array(rawData.slice(off, off + 256));\n            } else if (data) {\n                sector = data[t][physical_sector];\n            } else {\n                throw new Error('Requires data or rawData');\n            }\n            track = track.concat(\n                explodeSector13(volume, t, physical_sector, sector)\n            );\n        }\n        disk.tracks.push(new Uint8Array(track));\n    }\n\n    return disk;\n}\n","import { debug } from '../js/util';\nimport { jsonDecode } from '../js/formats/format_utils';\nimport { createDisk, createDiskFromJsonDisk } from '../js/formats/create_disk';\nimport {\n    FormatWorkerMessage,\n    DiskProcessedResponse,\n    DISK_PROCESSED,\n    PROCESS_BINARY,\n    PROCESS_JSON_DISK,\n    PROCESS_JSON,\n    FloppyDisk,\n} from '../js/formats/types';\n\ndebug('Worker loaded');\n\naddEventListener('message', (message: MessageEvent<FormatWorkerMessage>) => {\n    debug('Worker started', message.type);\n    const data = message.data;\n    const { driveNo } = data.payload;\n    let disk: FloppyDisk | null = null;\n\n    switch (data.type) {\n        case PROCESS_BINARY:\n            {\n                const { fmt, options } = data.payload;\n                disk = createDisk(fmt, options);\n            }\n            break;\n\n        case PROCESS_JSON_DISK:\n            {\n                const { jsonDisk } = data.payload;\n                disk = createDiskFromJsonDisk(jsonDisk);\n            }\n            break;\n\n        case PROCESS_JSON:\n            {\n                const { json } = data.payload;\n                disk = jsonDecode(json);\n            }\n            break;\n    }\n\n    const response: DiskProcessedResponse = {\n        type: DISK_PROCESSED,\n        payload: {\n            driveNo,\n            disk,\n        },\n    };\n\n    self.postMessage(response);\n\n    debug('Worker complete', message.type);\n});\n","/**\n * Extracts the members of a constant array as a type. Used as:\n *\n * @example\n * const SOME_VALUES = ['a', 'b', 1, 2] as const;\n * type SomeValues = MemberOf<typeof SOME_VALUES>; // 'a' | 'b' | 1 | 2\n */\nexport type MemberOf<T extends ReadonlyArray<unknown>> =\n    T extends ReadonlyArray<infer E> ? E : never;\n\n/**\n * Recursively extracts all members of a constant array as a type. Used as:\n *\n * @example\n * const SOME_ARRAYS = [['a'],['b', 2], 3] as const;\n * type SomeArrayValues = DeepMemberOf<typeof SOME_ARRAYS>; // 'a' | 'b' | 2 | 3\n */\nexport type DeepMemberOf<T extends ReadonlyArray<unknown>> =\n    T extends ReadonlyArray<infer E>\n        ? E extends ReadonlyArray<unknown>\n            ? DeepMemberOf<E>\n            : E\n        : never;\n\n/**\n * Extracts the declared keys of a type by removing `string` and `number`.\n *\n * Cribbed from the interwebs:\n * https://github.com/microsoft/TypeScript/issues/25987#issuecomment-408339599\n */\nexport type KnownKeys<T> = {\n    [K in keyof T]: string extends K ? never : number extends K ? never : K;\n} extends { [_ in keyof T]: infer U }\n    ? U\n    : never;\n\n/**\n * Extracts the declared values of a constant object.\n */\nexport type KnownValues<T> = T extends {\n    [_ in keyof T]: infer U;\n}\n    ? U\n    : never;\n\n/**\n * Replacement for `includes` on constant types that is also a type assertion.\n *\n * @example\n * const SOME_VALUES = [1, 2, 'a'] as const;\n * let n: number = 1;\n * let r = includes(SOME_VALUES, n); // r === true, n is 1 | 2 | 'a'\n * n = 5;\n * r = includes(SOME_VALUES, n); // r === false, n is number\n */\nexport function includes<S extends T, T>(a: ReadonlyArray<S>, v: T): v is S {\n    return (a as ReadonlyArray<T>).includes(v);\n}\n\n/** A bit. */\nexport type bit = 0 | 1;\n\n/** A nibble. */\nexport type nibble =\n    | 0x0\n    | 0x1\n    | 0x2\n    | 0x3\n    | 0x4\n    | 0x5\n    | 0x6\n    | 0x7\n    | 0x8\n    | 0x9\n    | 0xa\n    | 0xb\n    | 0xc\n    | 0xd\n    | 0xe\n    | 0xf;\n\n/** A byte (0..255). This is not enforced by the compiler. */\nexport type byte = number;\n\n/** A word (0..65535). This is not enforced by the compiler. */\nexport type word = number;\n\n/** A raw region of memory. */\nexport type memory = Uint8Array;\n\n/** A raw region of memory. */\nexport type rom = ReadonlyUint8Array;\n\nexport interface Memory {\n    /** Read a byte. */\n    read(page: byte, offset: byte): byte;\n    /** Write a byte. */\n    write(page: byte, offset: byte, value: byte): void;\n}\n\n/** A mapped region of memory. */\nexport interface MemoryPages extends Memory {\n    /** Start page. */\n    start(): byte;\n    /** End page, inclusive. */\n    end(): byte;\n}\n\n/* An interface card */\nexport interface Card<StateT = unknown> extends Memory, Restorable<StateT> {\n    /* Reset the card */\n    reset?(): void;\n\n    /* Draw card to canvas */\n    blit?(): ImageData | undefined;\n\n    /* Process period events */\n    tick?(): void;\n\n    /* Read or Write an I/O switch */\n    ioSwitch(off: byte, val?: byte): byte | undefined;\n}\n\nexport type TapeData = Array<[duration: number, high: boolean]>;\n\nexport interface Restorable<T = unknown> {\n    getState(): T | Promise<T>;\n    setState(state: T): void;\n}\n\n// Read-only typed arrays for constants\nexport type TypedArrayMutableProperties =\n    | 'copyWithin'\n    | 'fill'\n    | 'reverse'\n    | 'set'\n    | 'sort';\nexport interface ReadonlyUint8Array\n    extends Omit<Uint8Array, TypedArrayMutableProperties> {\n    readonly [n: number]: number;\n}\n\n// Readonly RGB color value\nexport type Color = readonly [r: byte, g: byte, b: byte];\n"],"names":["hex_digits","bytify","ary","Uint8Array","args","console","log","v","n","result","idx","B64","base64_decode","data","o1","o2","o3","h1","h2","h3","h4","bits","i","ac","tmp_arr","indexOf","charAt","length","ENCODING_NIBBLE","MemoryBlockDisk","constructor","format","metadata","readOnly","blocks","encoding","blockCount","this","read","block","write","NIBBLE_FORMATS","DO","PO","D13O","TRANS53","TRANS62","fourXfour","val","xx","yy","explodeSector16","volume","track","sector","gap","buf","push","checksum","concat","nibbles","idx2","idx6","val6","val2","last","explodeSector13","jdx","a5","a3","b5","b3","c5","c3","d5","d3","e5","e3","LookingFor","grabNibble","offset","nibble","waitForOne","createDiskFromDOS","options","name","side","rawData","disk","tracks","t","physical_sector","dos_sector","off","slice","Error","createDiskFromNibble","BLOCK_SIZE","createDiskFromProDOS","byteLength","physical_track","prodos_sector","OFFSETS","SIGNATURE","CREATOR","HEADER_LENGTH","VERSION","FORMAT","FLAGS","BLOCKS","DATA_OFFSET","DATA_LENGTH","COMMENT","COMMENT_LENGTH","CREATOR_DATA","CREATOR_DATA_LENGTH","PADDING","READ_ONLY","VOLUME_VALID","VOLUME_MASK","stringFromBytes","start","end","byteArray","buffer","byteOffset","String","fromCharCode","InfoChunk","sides","bootSector","bitTiming","compatibleHardware","requiredRAM","largestTrack","version","getUint8","diskType","writeProtected","synchronized","cleaned","creator","getUint16","TMapChunk","trackMap","TrksChunk","TrksChunk1","super","rawTracks","trackNo","rawTrack","trackData","trackBitCount","DataView","byteIndex","bitIndex","TrksChunk2","trks","startBlock","bitCount","getUint32","trk","MetaChunk","parts","split","values","reduce","acc","part","subParts","createDisk","fmt","bytes","prefix","decoder","TextDecoder","signature","decode","headerLength","getInt16","getInt32","flags","commentOffset","commentLength","creatorDataOffset","creatorDataLength","ProDOS","dataEnd","commentEnd","creatorDataEnd","extras","comment","creatorData","DOS","read2MGHeader","NIB","createDiskFrom2MG","disk_sector","dv","wozVersion","dvOffset","chunks","readChunk","type","size","WOZ_HEADER_START","readHeader","chunk","info","tmap","meta","createDiskFromWoz","addEventListener","message","driveNo","payload","jsonDisk","includes","s","createDiskFromJsonDisk","json","JSON","parse","_s","d","f","jsonDecode","response","self","postMessage"],"sourceRoot":""}